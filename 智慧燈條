#include <ETH.h>
#include <WiFi.h> // OTA éœ€è¦ WiFi.hï¼Œå³ä½¿æˆ‘å€‘ç”¨ä¹™å¤ªç¶²è·¯
#include <ArduinoOTA.h>
#include <ModbusIP_ESP8266.h>
#include <FastLED.h>

// ----------------------------------------------------------------
// 1. ç¡¬é«”èˆ‡ç¶²è·¯è¨­å®š (è«‹æ ¹æ“šæ‚¨çš„ç¡¬é«”ä¿®æ”¹)
// ----------------------------------------------------------------

// --- ä¹™å¤ªç¶²è·¯ PHY (IP101) è¨­å®š ---
#define ETH_PHY_TYPE   ETH_PHY_IP101
#define ETH_PHY_ADDR   1
#define ETH_MDC_PIN    23
#define ETH_MDIO_PIN   18
#define ETH_POWER_PIN  5
#define ETH_CLK_MODE   ETH_CLOCK_GPIO0_IN

// --- éœæ…‹ IP è¨­å®š ---
IPAddress ethIP(192, 168, 1, 70);    // ESP32 çš„ä¹™å¤ªç¶²è·¯éœæ…‹ IP
IPAddress ethGateway(192, 168, 1, 1); // æ‚¨çš„ç¶²è·¯é–˜é“
IPAddress ethSubnet(255, 255, 255, 0); // æ‚¨çš„å­ç¶²è·¯é®ç½©

// --- FastLED è¨­å®š ---
#define LED_PIN         4
#define NUM_LEDS        120 // æ ¹æ“šæ‚¨çš„ç‡ˆæ¢ä¿®æ”¹
#define LED_TYPE        WS2812B
#define COLOR_ORDER     GRB
CRGB leds[NUM_LEDS];

// --- OTA ä¸»æ©Ÿåç¨± ---
const char* ota_hostname = "esp32-ethernet-led";
const char* ota_password = "Sanjet25653819"; 

// --- LED æ•ˆæœè¨ˆæ™‚å™¨é–“éš” ---
// æ‚¨å¯ä»¥èª¿æ•´é€™äº›æ•¸å€¼ä¾†æ”¹è®Šå‹•æ…‹æ•ˆæœçš„é€Ÿåº¦
//const int flowinterval = 10;   // æµæ°´ç‡ˆé€Ÿåº¦ (ms)ï¼Œæ•¸å€¼è¶Šå°è¶Šå¿«
const int alarminterval = 20;  // æ•…éšœå‘¼å¸ç‡ˆé€Ÿåº¦ (ms)ï¼Œæ•¸å€¼è¶Šå°è¶Šå¿«

// ----------------------------------------------------------------
// 2. Modbus èˆ‡ LED æ§åˆ¶è®Šæ•¸
// ----------------------------------------------------------------
ModbusIP mb; // å»ºç«‹ ModbusIP ç‰©ä»¶

// --- Modbus æš«å­˜å™¨åœ°å€å®šç¾© ---
const int MODE_REG = 0;       // å°æ‡‰åœ°å€ 40001
const int RED_REG = 1;        // å°æ‡‰åœ°å€ 40002
const int GREEN_REG = 2;      // å°æ‡‰åœ°å€ 40003
const int BLUE_REG = 3;       // å°æ‡‰åœ°å€ 40004
const int BRIGHTNESS_REG = 4; // å°æ‡‰åœ°å€ 40005
const int SPEED_REG = 5;      // å°æ‡‰åœ°å€ 40006
const int PARAM_REG = 6;      // å°æ‡‰åœ°å€ 40007

// --- ç”¨æ–¼åœ¨æ ¸å¿ƒä¹‹é–“å‚³éè³‡æ–™çš„å…¨åŸŸè®Šæ•¸ ---
volatile int g_ledMode=0;
volatile int g_red = 0;
volatile int g_green = 0;
volatile int g_blue = 0;
volatile int g_brightness = 200;// é è¨­æ•´é«”äº®åº¦
volatile int g_speed = 255;
volatile int g_param = 0;//(æ–°!!) ç”¨æ–¼æ¨¡å¼6çš„åƒæ•¸

// --- FreeRTOS ä»»å‹™æ§åˆ¶ä»£ç¢¼ ---
TaskHandle_t ModbusTaskHandle;


// ================================================================
// === æ‚¨æä¾›çš„ LED åŠŸèƒ½å‡½å¼ (å·²æ•´åˆèˆ‡å„ªåŒ–) ===
// ================================================================

//----------------------------------------------------------------------------------------//
// å¾…æ©Ÿå‘¼å¸ç‡ˆ-- (æ¨¡å¼6)
// æ ¹æ“šå‚³å…¥çš„åƒæ•¸ para æ±ºå®šäº®ç‡ˆçš„å€æ®µ
void updateBreathEffect(int para) {
  unsigned long currentMillis = millis();
  static unsigned long previousMillis = 0;
  static int breathBrightness = 255;  // å‘¼å¸ç‡ˆçš„å…§éƒ¨äº®åº¦è®Šæ•¸
  static bool Direction = true;   
  int StepOn = 10;
  int StepOff = 10;
  /*
  // æ¢å¾©è¢«è¨»è§£çš„å‘¼å¸äº®åº¦è¨ˆç®—é‚è¼¯
  if (currentMillis - previousMillis >= 20) { // ä½¿ç”¨å›ºå®šçš„ interval
    previousMillis = currentMillis;
    
    if (Direction) {
      breathBrightness += StepOn;
    } else {
      breathBrightness -= StepOff;
    }

    if (breathBrightness >= 255) {
      breathBrightness = 255;
      Direction = false;
    } else if (breathBrightness <= 0) {
      breathBrightness = 0;
      Direction = true;
    }
  }
  */
  // è¨ˆç®—ç‡ˆç ç¯„åœ
  uint16_t regValue = constrain(para, 0, 1315);
  // æ‚¨çš„æ˜ å°„é‚è¼¯: map(regValue, 0, 1800, 114, 0);
  // é€™æœƒè®“ regValue=0 æ™‚ startLed=114, regValue=1800 æ™‚ startLed=0
  // é€™æ˜¯ä¸€å€‹åå‘æ˜ å°„ï¼Œæˆ‘å°‡å…¶ä¿ç•™
  int startLed = map(regValue, 0, 1800, NUM_LEDS, 0); 
  int endLed = startLed - 32; // äº®ç‡ˆé•·åº¦ç‚º32é¡†

  if (endLed < 0) {
    endLed = 0;
  }
  
  FastLED.clear(); // å…ˆæ¸…ç©ºæ‰€æœ‰ç‡ˆ
  for (int i = endLed; i < startLed; i++) {
    // é‚Šç•Œæª¢æŸ¥ï¼Œé˜²æ­¢iè¶…å‡ºé™£åˆ—ç¯„åœ
    if(i >= 0 && i < NUM_LEDS) {
      leds[i] = CRGB(0, breathBrightness, 0); // ç¶ è‰²å‘¼å¸
    }
  }
}

//----------------------------------------------------------------------------------------//
// æ–¹å‘æµæ°´ç‡ˆ-- (æ¨¡å¼3 & 4)
void FlowEffect(bool directionUp) {
  unsigned long currentMillis = millis();
  static unsigned long previousMillis = 0;
  static bool isLighting = true;
  static int currentIndex = 0;

  if (currentMillis - previousMillis >= (256 - g_speed)) { // g_speed è¶Šå¤§ï¼Œå»¶é²è¶Šå°ï¼Œé€Ÿåº¦è¶Šå¿«
    previousMillis = currentMillis;
    
    FastLED.clear();
    
    if (isLighting) {
      // é»äº®éšæ®µ
      if (directionUp) {
        for (int i = 0; i <= currentIndex; i++) {
          leds[i] = CRGB(222, 36, 1); 
        }
      } else {
        for (int i = NUM_LEDS - 1; i >= NUM_LEDS - 1 - currentIndex; i--) {
          leds[i] = CRGB(222, 36, 1); 
        }
      }

      currentIndex++;
      if (currentIndex >= NUM_LEDS) {
        isLighting = false;
        currentIndex = 0;
      }
    } else {
      // ç†„æ»…éšæ®µ
      if (directionUp) {
        for (int i = currentIndex; i < NUM_LEDS; i++) {
          leds[i] = CRGB(222, 36, 1);  
        }
      } else {
        for (int i = NUM_LEDS - 1 - currentIndex; i >= 0; i--) {
          leds[i] = CRGB(222, 36, 1);  
        }
      }

      currentIndex++;
      if (currentIndex >= NUM_LEDS) {
        isLighting = true;
        currentIndex = 0;
      }
    }
  }
}

//----------------------------------------------------------------------------------------//
// æ•…éšœç‹€æ…‹å‘¼å¸ç‡ˆ-- (æ¨¡å¼2)
void AlarmBreath() {
  unsigned long currentMillis = millis();
  static unsigned long previousMillis = 0;
  static int breathBrightness = 0; // å…§éƒ¨çš„äº®åº¦æ§åˆ¶
  static bool Direction = true;    // ON/OFFæ–¹å‘æ§åˆ¶
  static int StepOn = 15;
  static int StepOff = 25;
  
  if (currentMillis - previousMillis >= alarminterval) {
    previousMillis = currentMillis;

    if (Direction) {
      breathBrightness += StepOn;
    } else {
      breathBrightness -= StepOff;
    }
    
    if (breathBrightness >= 255) {
      breathBrightness = 255;
      Direction = false;
    } else if (breathBrightness <= 0) {
      breathBrightness = 0;
      Direction = true;
    }

    fill_solid(leds, NUM_LEDS, CRGB(breathBrightness, 0, 0)); // ç´…è‰²å‘¼å¸
  }
}

//----------------------------------------------------------------------------------------//
// å¤œåº—æ¨¡å¼ç‡ˆæ•ˆ (æ¨¡å¼5)
void NightClubEffect() {
  unsigned long currentMillis = millis();

  static const long colorChangeInterval = 80;   
  static const long strobeInterval = 100;     
  static uint8_t hue = 0;                    
  static bool strobeState = false;           
  static int colorBlockPosition = 0;         

  // å½©è™¹æ¼¸è®Šæ•ˆæœ
  static unsigned long rainbowPreviousMillis = 0;
  if (currentMillis - rainbowPreviousMillis >= colorChangeInterval) {
    rainbowPreviousMillis = currentMillis;
    hue += 2;
    fill_rainbow(leds, NUM_LEDS, hue, 7);
  }

  // é »é–ƒæ•ˆæœ
  static unsigned long strobePreviousMillis = 0;
  if (currentMillis - strobePreviousMillis >= strobeInterval) {
    strobePreviousMillis = currentMillis;
    strobeState = !strobeState;
    if(strobeState) {
      for(int i=0; i<NUM_LEDS; i++) { leds[i] += CRGB::White; }
    }
  }

  // æµå‹•è‰²å¡Šæ•ˆæœ
  static unsigned long blockPreviousMillis = 0;
  if (currentMillis - blockPreviousMillis >= 100) {
    blockPreviousMillis = currentMillis;
    colorBlockPosition = (colorBlockPosition + 1) % NUM_LEDS;
    for(int i=0; i<10; i++) {
      int pos = (colorBlockPosition + i) % NUM_LEDS;
      leds[pos] = CHSV(hue + 128, 255, 255); // å°æ¯”è‰²
    }
  }
}

// ================================================================
// === æ ¸å¿ƒç³»çµ±ç¨‹å¼ç¢¼ (èˆ‡ä¹‹å‰ç›¸åŒï¼Œä½†æœ‰å¾®èª¿) ===
// ================================================================
// 1. æ–°å¢ debug è¼¸å‡ºåŠŸèƒ½ï¼Œç”¨æ–¼é¡¯ç¤º master ç™¼é€çš„ Modbus è³‡æ–™è®Šæ›´
// 2. å¢åŠ æª¢æŸ¥æ˜¯å¦æœ‰æš«å­˜å™¨è®ŠåŒ–å†æ›´æ–°å…¨åŸŸè®Šæ•¸ï¼Œé¿å…ä¸å¿…è¦çš„å¯«å…¥
// 3. ç§»é™¤æœªä½¿ç”¨è®Šæ•¸èˆ‡ç°¡åŒ–é‚è¼¯çµæ§‹
// ----------------------------------------------------------------
// 3. Modbus ä¼ºæœå™¨ä»»å‹™ (é‹è¡Œæ–¼æ ¸å¿ƒ 0)
// ----------------------------------------------------------------
void ModbusTask(void *pvParameters) {
  Serial.println("Modbus TCP ä»»å‹™å·²åœ¨æ ¸å¿ƒ 0 ä¸Šå•Ÿå‹•");
  int prev_ledMode = g_ledMode;
  int prev_red = g_red;
  int prev_green = g_green;
  int prev_blue = g_blue;
  int prev_brightness = g_brightness;
  int prev_speed = g_speed;
  int prev_param = g_param;

  for (;;) {
    mb.task();

    // æ¯”è¼ƒä¸¦æ›´æ–°æš«å­˜å™¨è®Šæ•¸ï¼Œè‹¥æœ‰è®Šæ›´å‰‡æ‰“å°
    int mode = mb.Hreg(MODE_REG);
    if (mode != prev_ledMode) {
      Serial.printf("[Modbus] MODE æ”¹è®Š: %d -> %d\n", prev_ledMode, mode);
      prev_ledMode = g_ledMode = mode;
    }

    int red = mb.Hreg(RED_REG);
    if (red != prev_red) {
      Serial.printf("[Modbus] RED æ”¹è®Š: %d -> %d\n", prev_red, red);
      prev_red = g_red = red;
    }

    int green = mb.Hreg(GREEN_REG);
    if (green != prev_green) {
      Serial.printf("[Modbus] GREEN æ”¹è®Š: %d -> %d\n", prev_green, green);
      prev_green = g_green = green;
    }

    int blue = mb.Hreg(BLUE_REG);
    if (blue != prev_blue) {
      Serial.printf("[Modbus] BLUE æ”¹è®Š: %d -> %d\n", prev_blue, blue);
      prev_blue = g_blue = blue;
    }

    int bright = mb.Hreg(BRIGHTNESS_REG);
    if (bright != prev_brightness) {
      Serial.printf("[Modbus] BRIGHTNESS æ”¹è®Š: %d -> %d\n", prev_brightness, bright);
      prev_brightness = g_brightness = bright;
    }

    int spd = mb.Hreg(SPEED_REG);
    if (spd != prev_speed) {
      Serial.printf("[Modbus] SPEED æ”¹è®Š: %d -> %d\n", prev_speed, spd);
      prev_speed = g_speed = spd;
    }

    int param = mb.Hreg(PARAM_REG);
    if (param != prev_param) {
      Serial.printf("[Modbus] PARAM æ”¹è®Š: %d -> %d\n", prev_param, param);
      prev_param = g_param = param;
    }

    vTaskDelay(pdMS_TO_TICKS(10));
  }
}

// ----------------------------------------------------------------
// 4. LED æ•ˆæœä¸»æ§å‡½å¼ (ç”±æ ¸å¿ƒ 1 çš„ loop å‘¼å«)
// ----------------------------------------------------------------
void updateLedController() {
  switch (g_ledMode) {
    case 0: // æ¨¡å¼ 0: é—œé–‰
      FastLED.clear();
      break;

    case 1: // æ¨¡å¼ 1: éœæ…‹å–®è‰²
      fill_solid(leds, NUM_LEDS, CRGB(g_red, g_green, g_blue));
      break;
      
    case 2: // æ¨¡å¼ 2: æ•…éšœå‘¼å¸ç‡ˆ (ç´…è‰²)
      AlarmBreath();
      break;

    case 3: // æ¨¡å¼ 3: æ–¹å‘æµæ°´ç‡ˆ (ä¸Š)
      FlowEffect(true);
      break;
      
    case 4: // æ¨¡å¼ 4: æ–¹å‘æµæ°´ç‡ˆ (ä¸‹)
      FlowEffect(false);
      break;

    case 5: // æ¨¡å¼ 5: å¤œåº—æ¨¡å¼
      NightClubEffect();
      break;

    case 6: // æ¨¡å¼ 6: å¾…æ©Ÿå‘¼å¸ç‡ˆ (ç¶ è‰²ï¼Œå¸¶åƒæ•¸)
      updateBreathEffect(g_param);
      break;
      
    default: // æœªçŸ¥æ¨¡å¼ï¼Œé—œé–‰
      FastLED.clear();
      break;
  }
}

// ----------------------------------------------------------------
// 5. Arduino ä¸»è¦è¨­å®šå‡½å¼ (é‹è¡Œæ–¼æ ¸å¿ƒ 1)
// ----------------------------------------------------------------
void setup() {
  Serial.begin(115200);
  Serial.println("\nESP32 ä¹™å¤ªç¶²è·¯ LED æ§åˆ¶å™¨å•Ÿå‹•ä¸­ ...");

  //---------------------------------------------------------------
  // --- åˆå§‹åŒ–ä¹™å¤ªç¶²è·¯ ---
  Serial.println("æ­£åœ¨å•Ÿå‹•ä¹™å¤ªç¶²è·¯...");
  // æŸäº›æ¿å­éœ€è¦ GPIO0 çš„æ™‚è„ˆè¨Šè™Ÿï¼ŒåŠ ä¸Šé€™è¡Œæ›´ç©©å®š
  pinMode(ETH_POWER_PIN, OUTPUT);
  digitalWrite(ETH_POWER_PIN, HIGH);  // æ‹‰é«˜è§£é™¤ Reset
  delay(100);
   
  pinMode(0, INPUT_PULLUP);
  ETH.begin(
    ETH_PHY_TYPE,     // ğŸŸ¢ æ­£ç¢ºç¬¬ 1 åƒæ•¸ï¼šPHY é¡å‹
    ETH_PHY_ADDR,     // ğŸŸ¢ PHY åœ°å€
    ETH_MDC_PIN,      // ğŸŸ¢ MDC è…³ä½
    ETH_MDIO_PIN,     // ğŸŸ¢ MDIO è…³ä½
    ETH_POWER_PIN,    // ğŸŸ¢ é›»æºè…³ä½
    ETH_CLK_MODE      // ğŸŸ¢ REF_CLK æ¨¡å¼
  );
  //---------------------------------------------------------------

  // è¨­å®šéœæ…‹ IP
  if (!ETH.config(ethIP, ethGateway, ethSubnet)) {
    Serial.println("è¨­å®šéœæ…‹ IP å¤±æ•—ï¼");
  }

  Serial.println("ç­‰å¾…ä¹™å¤ªç¶²è·¯é€£æ¥...");
  while (!ETH.linkUp()) { delay(500); Serial.print("."); }
  Serial.println("\nä¹™å¤ªç¶²è·¯å·²é€£æ¥");
  Serial.print("IP ä½å€: "); Serial.println(ETH.localIP());

  // --- åˆå§‹åŒ– FastLED ---
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
  FastLED.setBrightness(g_brightness);
  FastLED.clear();
  FastLED.show();
  Serial.println("FastLED åˆå§‹åŒ–å®Œæˆ");

  // --- è¨­å®š Modbus ä¼ºæœå™¨ ---
  mb.addHreg(MODE_REG, g_ledMode);
  mb.addHreg(RED_REG, g_red);
  mb.addHreg(GREEN_REG, g_green);
  mb.addHreg(BLUE_REG, g_blue);
  mb.addHreg(BRIGHTNESS_REG, g_brightness);
  mb.addHreg(SPEED_REG, g_speed);
  mb.addHreg(PARAM_REG, g_param); // (æ–°!!) åˆå§‹åŒ–åƒæ•¸æš«å­˜å™¨
  mb.server();
  Serial.println("Modbus TCP ä¼ºæœå™¨å·²è¨­å®š");
  
  // --- è¨­å®š OTA ---
  ArduinoOTA.setHostname(ota_hostname);
  ArduinoOTA.setPassword(ota_password);
  ArduinoOTA.onStart([]() { Serial.println("OTA é–‹å§‹æ›´æ–°..."); }).onEnd([]() { Serial.println("\nOTA æ›´æ–°å®Œæˆ"); }).onProgress([](unsigned int progress, unsigned int total) { Serial.printf("é€²åº¦: %u%%\r", (progress / (total / 100))); }).onError([](ota_error_t error) { Serial.printf("OTA éŒ¯èª¤ [%u]\n", error); });
  ArduinoOTA.begin();
  Serial.println("OTA æœå‹™å·²æº–å‚™å°±ç·’");

  // --- å»ºç«‹ä¸¦å•Ÿå‹• Modbus ä»»å‹™ï¼Œå›ºå®šåœ¨æ ¸å¿ƒ 0 ---
  xTaskCreatePinnedToCore(ModbusTask, "ModbusTCPServer", 4096, NULL, 1, &ModbusTaskHandle, 0);
  
  delay(500);
  Serial.println("ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼Œå·²é€²å…¥ä¸»è¿´åœˆã€‚");
}

// ----------------------------------------------------------------
// 6. Arduino ä¸»è¿´åœˆ (é‹è¡Œæ–¼æ ¸å¿ƒ 1)
// ----------------------------------------------------------------
void loop() {
  // è™•ç† OTA è«‹æ±‚
  ArduinoOTA.handle();

  // æ›´æ–° LED æ•ˆæœ
  updateLedController();
  
  // å°‡æ‰€æœ‰ LED æ•¸æ“šä¸€æ¬¡æ€§ç™¼é€åˆ°ç‡ˆæ¢
  // ä¸¦æ‡‰ç”¨ç”± Modbus æ§åˆ¶çš„å…¨åŸŸäº®åº¦
  FastLED.setBrightness(g_brightness);
  FastLED.show();

  // çŸ­æš«å»¶é²
  delay(1);
}
