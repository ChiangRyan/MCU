#include <WiFi.h>
#include <WebServer.h>
#include <Arduino_JSON.h> // 使用 Arduino_JSON 庫
#include <ETH.h>
#include <ModbusIP_ESP8266.h>

/*
#include <FastLED.h>
// 定義WS2812B LED的參數
#define LED_PIN     5         // ESP32連接到WS2812B的數據腳位
#define NUM_LEDS    6        // LED燈條的LED數量
#define LED_TYPE    WS2812B  // LED類型
#define COLOR_ORDER GRB      // 顏色順序
// 創建LED陣列
CRGB leds[NUM_LEDS];
*/

// WiFi 設定
const char* ssid = "1F_IOT";              // 替換為你的 WiFi SSID
const char* password = "sanjet25653819";  // 替換為你的 WiFi 密碼
// 初始化 WiFi（帶超時重試機制）
const unsigned long WIFI_TIMEOUT = 10000; // 10 秒超時
const int WIFI_MAX_RETRIES = 3; // 最大重試次數
int wifi_retries = WIFI_MAX_RETRIES;
bool wifi_connected = false;
// 新增：RSSI 打印任務的函式原型
void printRSSITask(void *pvParameters);

// 內建指示LED引腳
#define LED_BUILTIN 2  // ESP32 內建藍色 LED，通常在 GPIO 2（請確認你的模組）

// LAN8720 引腳配置
#define ETH_TYPE       ETH_PHY_LAN8720
#define ETH_ADDR       1
#define ETH_POWER_PIN  -1
#define ETH_MDC_PIN    23
#define ETH_MDIO_PIN   18
#define ETH_CLK_MODE   ETH_CLOCK_GPIO0_IN

// 乙太網路和 Modbus 設定
IPAddress ethIP(192, 168, 1, 71);  // ESP32 的乙太網路靜態 IP
ModbusIP mb;

// Modbus 數據
const uint8_t numCoils = 5;  // Coil 數量（地址 0-4）
const uint8_t numHoldingRegisters = 12;  // Holding Register 數量（地址 0-12）
#define MAX_SLAVES 10  // 模擬從站數量（這裡僅用於 Web 介面，實際只有 1 個從站）

// Web 伺服器，監聽埠 80
WebServer server(80);

void setup() {
  // 初始化串口
  Serial.begin(115200);

  // 初始化 LED 引腳
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW); // 初始關閉 LED

  // 初始化 WiFi（帶超時重試機制）
  while (wifi_retries > 0 && !wifi_connected) {
    Serial.print("Connecting to WiFi...");
    WiFi.begin(ssid, password);
    unsigned long startTime = millis();

    while (WiFi.status() != WL_CONNECTED && (millis() - startTime) < WIFI_TIMEOUT) {
      delay(500);
      Serial.print(".");
    }

    if (WiFi.status() == WL_CONNECTED) {
      wifi_connected = true;
      Serial.println("\nWiFi connected");
      Serial.print("ESP32 WiFi IP address: ");
      Serial.println(WiFi.localIP());
      // 打印一次初始的 RSSI
      long rssi = WiFi.RSSI();
      Serial.print("Initial WiFi Signal Strength (RSSI): ");
      Serial.print(rssi);
      Serial.println(" dBm");
    } else {
      wifi_retries--;
      Serial.println("\nWiFi connection failed, timeout after 10 seconds");
      WiFi.disconnect(); // 斷開當前連線，準備重試
      if (wifi_retries > 0) {
        Serial.printf("Retrying WiFi connection (%d attempts left)...\n", wifi_retries);
        delay(1000); // 等待 1 秒後重試
      }
    }
  }

  if (!wifi_connected) {
    Serial.println("WiFi connection failed after all retries");
    while (true) {
      digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); // 快速閃爍表示錯誤
      delay(100);
    }
  }

  // 創建並啟動 RSSI 打印任務
  // 確保 WiFi 已連接才創建任務
  if (wifi_connected) {
    xTaskCreatePinnedToCore(
      printRSSITask,    // 要執行的函式
      "PrintRSSITask",  // 任務名稱 (用於偵錯)
      2048,             // 堆疊大小 (Bytes) -> 調整為 words (2048 words = 8192 bytes)
      NULL,             // 傳遞給任務的參數
      1,                // 任務優先級 (0 是最低)
      NULL,             // 任務句柄 (可選)
      0                 // 將任務固定到核心 0 (核心 1 通常運行 Arduino loop 和 WiFi/BT)
    );
    Serial.println("RSSI printing task created and pinned to core 0.");
  }

  // 初始化乙太網路
  Serial.println("Starting Ethernet...");
  bool eth_initialized = false;
  int retries = 3;

  while (retries > 0 && !eth_initialized) {
    delay(1000); // 等待 1 秒，讓 PHY 穩定
    eth_initialized = ETH.begin(ETH_TYPE, ETH_ADDR, ETH_MDC_PIN, ETH_MDIO_PIN, ETH_POWER_PIN, ETH_CLK_MODE);
    if (!eth_initialized) {
      Serial.println("ETH.begin() failed, retrying...");
      delay(1000); // 等待 1 秒後重試
      retries--;
    }
  }
  if (!eth_initialized) {
    Serial.println("ETH.begin() failed after 3 retries, restarting ESP32...");
    delay(1000); // 延遲 1 秒，讓用戶可以看到訊息
    ESP.restart(); // 觸發重啟
  }

  // 設置乙太網路靜態 IP
  IPAddress gateway(192, 168, 1, 1);
  IPAddress subnet(255, 255, 255, 0);
  ETH.config(ethIP, gateway, subnet);

  // 等待乙太網路連接
  while (!ETH.linkUp()) {
    Serial.println("Ethernet is connecting...");
    delay(1000);
  }

  Serial.println("Ethernet connected");
  Serial.print("Ethernet IP Address: ");
  Serial.println(ETH.localIP());

  // 初始化 Modbus TCP 從站
  mb.server();  // 設置為 Modbus TCP 伺服器（從站）
  for (int i = 0; i < numCoils; i++) {
    mb.addCoil(i);  // 添加 Coil（地址 0-4）
    mb.Coil(i, false);  // 初始值設為 false
  }
  for (int i = 0; i < numHoldingRegisters; i++) {
    mb.addHreg(i);  // 添加 Holding Register（地址 0-1）
    //mb.Hreg(i, 0);  // 初始值設為 0
  }
  Serial.println("Modbus TCP Slave Ready on 192.168.1.71:502");

  // 定義 HTTP 路由
  server.on("/", handleRoot);          // 根路徑
  server.on("/setLED", handleSetLED);  // LED 控制
  server.on("/readModbus", handleReadModbus); // Modbus 資料查詢
  server.on("/writeModbus", handleWriteModbus); // Modbus 寫入
  server.begin();
  Serial.println("HTTP server started on WiFi IP: " + WiFi.localIP().toString());

  // 所有初始化完成後，點亮 LED
  digitalWrite(LED_BUILTIN, HIGH);
  Serial.println("Initialization completed successfully, LED turned on");

  /*
  // 初始化FastLED庫
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  FastLED.setBrightness(150); // 設置亮度 (0-255)
  Serial.println("FastLED initialized.");
  // 初始關閉所有LED
  for(int i = 0; i < NUM_LEDS; i++) {
    leds[i] = CRGB::Black;
  }
  FastLED.show();
  */
}


// RSSI 打印及 WiFi 重連任務的實作
void printRSSITask(void *pvParameters) {
  Serial.println("RSSI Printing & WiFi Reconnect Task started on core " + String(xPortGetCoreID()));
  
  unsigned long lastReconnectAttemptTime = 0;          // 上次嘗試重連的時間戳
  const unsigned long reconnectInterval = 10000;       // 若斷線，每隔多久嘗試一次完整的重連流程 (例如 10 秒)
  const unsigned long wifiConnectionTimeout = 10000;   // 單次 WiFi.begin() 連線嘗試的超時時間 (例如 10 秒)
  bool ledWasTurnedOffByTask = false;                  // 標記 LED 是否被此任務因斷線而關閉

  for (;;) { // 無窮迴圈
    if (WiFi.status() == WL_CONNECTED) {
      // WiFi 已連線
      if (digitalRead(LED_BUILTIN) == LOW && ledWasTurnedOffByTask) {
        // 如果 LED 是暗的，且是本任務因斷線而關閉它的，則重新點亮
        digitalWrite(LED_BUILTIN, HIGH);
        Serial.println("[WiFi Task] WiFi reconnected. LED_BUILTIN turned ON.");
        ledWasTurnedOffByTask = false; // 重置標記
      } else if (digitalRead(LED_BUILTIN) == LOW && WiFi.status() == WL_CONNECTED) {
        // 如果因為其他原因 (例如 /setLED) LED是暗的，但WiFi是連著的，我們也可以選擇點亮它
        // 這取決於您希望 LED_BUILTIN 是否嚴格代表 WiFi 連線狀態
        // 為保持與 setup() 後的狀態一致，如果WiFi連著就應該亮，除非被手動關閉
        // 但若要完全尊重 /setLED 的操作，這裡可以不做自動點亮，除非是 ledWasTurnedOffByTask
      }

      // 重置上次重連嘗試時間，因為現在已經連線了
      lastReconnectAttemptTime = 0;

      long rssi = WiFi.RSSI();
      Serial.print("[WiFi Task] WiFi Signal: ");
      Serial.print(rssi);
      Serial.println(" dBm");

    } else {
      // WiFi 未連線
      Serial.println("[WiFi Task] WiFi is disconnected.");
      if (digitalRead(LED_BUILTIN) == HIGH) {
        digitalWrite(LED_BUILTIN, LOW);
        Serial.println("[WiFi Task] LED_BUILTIN turned OFF due to disconnection.");
        ledWasTurnedOffByTask = true; // 標記 LED 是被此任務關閉的
      }

      unsigned long currentTime = millis();
      // 檢查是否到了嘗試重連的時間
      // lastReconnectAttemptTime == 0 表示是第一次檢測到斷線後，或剛連線成功後
      if (lastReconnectAttemptTime == 0 || (currentTime - lastReconnectAttemptTime) >= reconnectInterval) {
        Serial.println("[WiFi Task] Attempting to reconnect to WiFi...");
        
        WiFi.disconnect(true); // 清理之前的連線狀態
        delay(100);            // 短暫延遲
        WiFi.mode(WIFI_STA);   // 確保是 STA 模式
        
        // 如果您設定了靜態 IP，WiFi.config() 的設定通常會被保留。
        // 但如果遇到問題，可以在 WiFi.begin() 前重新呼叫 WiFi.config(...)
        // 例如:
        // if (use_static_ip) { // 假設您有一個變數來判斷是否使用靜態IP
        //   if (!WiFi.config(local_IP, gateway, subnet, primaryDNS, secondaryDNS)) {
        //     Serial.println("[WiFi Task] Failed to re-configure static IP for reconnection.");
        //   }
        // }

        WiFi.begin(ssid, password); // 開始連線
        lastReconnectAttemptTime = currentTime; // 更新此次嘗試的時間

        unsigned long connectStartTime = millis();
        Serial.print("[WiFi Task] Waiting for WiFi connection ");
        
        while (WiFi.status() != WL_CONNECTED && (millis() - connectStartTime) < wifiConnectionTimeout) {
          Serial.print(".");
          // 注意：這裡的 delay 會阻塞此任務，但不影響 WebServer (它在不同任務/核心)
          // 也代表在重連的這段時間 (最多 wifiConnectionTimeout)，此任務不會做其他事 (如更頻繁地打印 RSSI)
          delay(500); 
        }
        Serial.println(); // 結束打印點點

        if (WiFi.status() == WL_CONNECTED) {
          Serial.println("[WiFi Task] Successfully reconnected to WiFi!");
          Serial.print("[WiFi Task] New IP address: ");
          Serial.println(WiFi.localIP());
          // LED 會在下一次迴圈的已連線邏輯中被點亮
          ledWasTurnedOffByTask = true; // 確保下次連線成功時能正確亮燈
        } else {
          Serial.println("[WiFi Task] Failed to reconnect to WiFi within timeout.");
          WiFi.disconnect(true); // 如果連線失敗，確保完全斷開
        }
      } else {
        // 還沒到下次嘗試重連的時間
        // Serial.printf("[WiFi Task] Next reconnection attempt in ~%lu seconds.\n", (reconnectInterval - (currentTime - lastReconnectAttemptTime)) / 1000);
      }
    }
    // 此任務的迴圈延遲，決定了檢查 WiFi 狀態的頻率
    vTaskDelay(pdMS_TO_TICKS(1000)); // 維持您原有的1秒檢查間隔
  }
}


void loop() {
  mb.task();  // 處理 Modbus 請求
  server.handleClient(); // 處理客戶端請求
  delay(10);  // 輪詢間隔
}

/*
void LedShow(){
  // 將前六顆LED設為紅色
  for(int i = 0; i < 6; i++) {
    leds[i] = CRGB::Red;
  }
  FastLED.show();
  delay(300); // 延遲50ms

  // 將前六顆LED設為藍色
  for(int i = 0; i < 6; i++) {
    leds[i] = CRGB::Blue;
  }
  FastLED.show();
  delay(300); // 延遲50ms
}
*/


// 處理根路徑請求
void handleRoot() {
  server.send(200, "text/plain", "ESP32 LED Control and Modbus TCP Slave (via Ethernet)");
}

// 處理 LED 控制請求
void handleSetLED() {
  JSONVar response; // 使用 JSONVar 來構建 JSON 物件

  if (server.hasArg("state")) {
    String state = server.arg("state");
    if (state == "ON") {
      digitalWrite(LED_BUILTIN, HIGH);
      response["Status"] = "success";
      response["Message"] = "LED turned on";
      Serial.println("LED turned on");
    } else if (state == "OFF") {
      digitalWrite(LED_BUILTIN, LOW);
      response["Status"] = "success";
      response["Message"] = "LED turned off";
      Serial.println("LED turned off");
    } else {
      response["Status"] = "error";
      response["Message"] = "Invalid state parameter: " + state;
      Serial.println("Invalid state parameter: " + state);
    }
  } else {
    response["Status"] = "error";
    response["Message"] = "Missing state parameter";
    Serial.println("Missing state parameter");
  }

  String jsonString = JSON.stringify(response);
  server.send(200, "application/json", jsonString);
}

// 處理 Modbus 資料查詢請求
void handleReadModbus() {
  JSONVar response; // 使用 JSONVar 來構建 JSON 物件

  if (server.hasArg("slaveId") && server.hasArg("address") && server.hasArg("quantity") && server.hasArg("functionCode")) {
    uint8_t slaveId = server.arg("slaveId").toInt();
    uint16_t address = server.arg("address").toInt();
    uint8_t quantity = server.arg("quantity").toInt();
    uint8_t functionCode = server.arg("functionCode").toInt();

    if (slaveId < 1 || slaveId > MAX_SLAVES) {
      response["Status"] = "error";
      response["Message"] = "Invalid slaveId, must be between 1 and " + String(MAX_SLAVES);
      Serial.println("Invalid slaveId: " + String(slaveId));
    } else if (quantity < 1 || quantity > 10) { // 限制讀取數量以避免緩衝區溢位
      response["Status"] = "error";
      response["Message"] = "Invalid quantity, must be between 1 and 10";
      Serial.println("Invalid quantity: " + String(quantity));
    } else {
      response["Status"] = "success";
      response["SlaveId"] = slaveId;

      if (functionCode == 1) { // 讀取 Coil
        JSONVar dataArray = JSONVar(); // 創建一個陣列來儲存數據
        for (uint8_t i = 0; i < quantity; i++) {
          uint16_t coilAddr = address + i;
          if (coilAddr < numCoils) {
            bool coilValue = mb.Coil(coilAddr);
            dataArray[i] = coilValue;
          } else {
            dataArray[i] = 0; // 超出範圍返回 0
          }
        }
        response["Data"] = dataArray;
        Serial.println("Modbus read successful (Coil, Slave " + String(slaveId) + ", Address " + String(address) + "): " + JSON.stringify(dataArray));
      } 
      else if (functionCode == 3) { // 讀取 Holding Register
        JSONVar dataArray = JSONVar(); // 創建一個陣列來儲存數據
        for (uint8_t i = 0; i < quantity; i++) {
          uint16_t regAddr = address + i;
          if (regAddr < numHoldingRegisters) {
            uint16_t regValue = mb.Hreg(regAddr);
            dataArray[i] = regValue;
          } else {
            dataArray[i] = 0; // 超出範圍返回 0
          }
        }
        response["Data"] = dataArray;
        String jsonString = JSON.stringify(response);
        Serial.println(jsonString);      
      } 
      else {
        response["Status"] = "error";
        response["Message"] = "Unsupported function code: " + String(functionCode);
        Serial.println("Unsupported function code: " + String(functionCode));
      }
    }
  } else {
    response["Status"] = "error";
    response["Message"] = "Missing slaveId, address, quantity, or functionCode parameters";
    Serial.println("Missing slaveId, address, quantity, or functionCode parameters");
  }

  String jsonString = JSON.stringify(response);
  server.send(200, "application/json", jsonString);
}

// 處理 Modbus 寫入請求
void handleWriteModbus() {
  JSONVar response; // 使用 JSONVar 來構建 JSON 物件

  if (server.hasArg("slaveId") && server.hasArg("address") && server.hasArg("value") && server.hasArg("functionCode")) {
    uint8_t slaveId = server.arg("slaveId").toInt();
    uint16_t address = server.arg("address").toInt();
    uint16_t value = server.arg("value").toInt();
    uint8_t functionCode = server.arg("functionCode").toInt();

    if (slaveId < 1 || slaveId > MAX_SLAVES) {
      response["Status"] = "error";
      response["Message"] = "Invalid slaveId, must be between 1 and " + String(MAX_SLAVES);
      Serial.println("Invalid slaveId: " + String(slaveId));
    } else {
      bool success = false;
      if (functionCode == 5 && address < numCoils) { // 寫入 Coil
        mb.Coil(address, value != 0);
        success = true;
      } else if (functionCode == 6 && address < numHoldingRegisters) { // 寫入 Holding Register
        mb.Hreg(address, value);
        success = true;
      }

      if (success) {
        response["Status"] = "success";
        response["SlaveId"] = slaveId;
        response["Message"] = "Write successful";
        Serial.println("Modbus write successful (Slave " + String(slaveId) + "): Address=" + String(address) + ", Value=" + String(value));
      } else {
        response["Status"] = "error";
        response["SlaveId"] = slaveId;
        response["Message"] = "Write failed, invalid address or function code";
        Serial.println("Modbus write failed (Slave " + String(slaveId) + "), Address=" + String(address));
      }
    }
  } else {
    response["Status"] = "error";
    response["Message"] = "Missing slaveId, address, value, or functionCode parameters";
    Serial.println("Missing slaveId, address, value, or functionCode parameters");
  }

  String jsonString = JSON.stringify(response);
  server.send(200, "application/json", jsonString);
}
